
namespace BE {

   namespace 错误集 {

      inline constexpr 类型错误 时间错误 = C("提供了不正确的年月日、时分秒信息！");

   }

   /**
    * \brief >>> 一个负责进行简单时间管理的类，支持编译期类，通过基本的日期判断和简单的加减运算操作。
    * \brief >>> 注意的是，类不保存起始年信息，这意味着可能两个年月日相同的时间但时间戳并不相同。
    */
   struct 时间类 : 错误类
   {
      using EGO = void;
      
      enum class 时间枚举 : T::U8 { 年, 月, 日, 时, 分, 秒, 毫秒, 结束 };

      constexpr 时间类(const 时间类 &) noexcept = default;

      // 使用给定的时间戳构造时间，默认使用当前时间（这将导致类无法成为编译期类）。
      constexpr 时间类(类型时间 时间戳项 = 时间集::获取本地时间戳(), 类型日期 起始年项 = 时间集::起始年份) noexcept
      {
         this->赋值(时间戳项, 起始年项);
      }

      // 使用给定的年月日时分秒信息构造时间，如果时间错误则设置错误信息并退出函数。
      constexpr 时间类(类型日期 年份项, 类型日期 月份项, 类型日期 天数项, 类型日期 时钟项 = 0, 类型日期 分钟项 = 0, 类型日期 秒钟项 = 0, 类型日期 起始年项 = 时间集::起始年份) noexcept
      {
         this->赋值(年份项, 月份项, 天数项, 时钟项, 分钟项, 秒钟项, 起始年项);
      }

      /**
       * \brief >>> 使用给定的时间戳进行赋值。
       * 
       * \param 时间戳项： 时间戳信息。
       * \param 起始年项： 规定时间戳起始的年份，默认为 1970 年。
       * \return this &
       */
      constexpr 时间类 &赋值(类型时间 时间戳项, 类型日期 起始年项 = 时间集::起始年份) noexcept
      {
         this->类中时间项 = 时间集::解析时间戳(时间戳项, 起始年项);

         return *this;
      }

      /**
       * \brief >>> 使用给定的年月日时分秒信息进行赋值，如果时间错误则设置错误信息并退出函数。
       * 
       * \param 年份项： 年份信息。
       * \param 月份项： 月份信息。
       * \param 天数项： 天数信息。
       * \param 时钟项： 时钟信息，默认为 0。
       * \param 分钟项： 分钟信息，默认为 0。
       * \param 秒钟项： 秒钟信息，默认为 0。
       * \param 起始年项： 规定时间戳起始的年份，默认为 1970 年。
       * \return this &
       */
      constexpr 时间类 &赋值(类型日期 年份项, 类型日期 月份项, 类型日期 天数项, 类型日期 时钟项 = 0, 类型日期 分钟项 = 0, 类型日期 秒钟项 = 0, 类型日期 起始年项 = 时间集::起始年份) noexcept
      {
         if (时间集::日期有效判断({ 年份项, 月份项, 天数项, 时钟项, 分钟项, 秒钟项 }) == 假)
         {
            this->设置错误(错误集::时间错误);
            return *this;
         }

         this->类中时间项 = 时间集::解析时间戳(时间集::推算总秒({ 年份项, 月份项, 天数项, 时钟项, 分钟项, 秒钟项 }, 起始年项), 起始年项);

         return *this;
      }

      /**
       * \brief >>> 获取类中存储的时间结构。
       * 
       * \return 只读的时间结构引用。
       */
      constexpr const 时间结构 &获取结构() const noexcept
      {
         return this->类中时间项;
      }

      /**
       * \brief >>> 获取类中存储的时间戳。
       * 
       * \return 时间戳。
       */
      constexpr 类型时间 获取时间戳() const noexcept
      {
         return this->类中时间项.总时间;
      }

      /**
       * \brief >>> 比较两者的时间戳是否相等，来判断时间是否相等。
       * 
       * \param 比较项： 要比较的对象。
       * \return 相等则返回真，否则返回假。
       */
      constexpr 类型逻辑 相等判断(const 时间类 &比较项) const noexcept
      {
         return this->类中时间项.总时间 == 比较项.类中时间项.总时间;
      }

      /**
       * \brief >>> 比较两者的时间戳，来判断时间的大小。
       * 
       * \param 比较项： 要比较的对象。
       * \return 大于比较项则返回大于零的值，等于则返回零，小于则返回小于零的值。
       */
      constexpr 类型比较 比较判断(const 时间类 &比较项) const noexcept
      {
         return this->类中时间项.总时间 < 比较项.类中时间项.总时间 ? -1 : (this->类中时间项.总时间 > 比较项.类中时间项.总时间 ? 1 : 0);
      }

      /**
       * \brief >>> 判断当前日期是否为闰年。
       * 
       * \return 是则返回真，否则返回假。
       */
      constexpr 类型逻辑 闰年判断() const noexcept
      {
         return 时间集::闰年判断(this->类中时间项.年);
      }

      /**
       * \brief >>> 根据当前时间获取星座的字符数组名称。
       * 
       * \return 长度为 3 的字符数组引用。
       */
      constexpr auto 获取星座() const noexcept -> const 类型字符(&)[3]
      {
         if ((this->类中时间项.月 == 12 && this->类中时间项.日 >= 21) || (this->类中时间项.月 == 1 && this->类中时间项.日 <= 19))
         {
            return C("摩羯");
         }
         else if ((this->类中时间项.月 == 1 && this->类中时间项.日 >= 20) || (this->类中时间项.月 == 2 && this->类中时间项.日 <= 18))
         {
            return C("水瓶");
         }
         else if ((this->类中时间项.月 == 2 && this->类中时间项.日 >= 19) || (this->类中时间项.月 == 3 && this->类中时间项.日 <= 20))
         {
            return C("双鱼");
         }
         else if ((this->类中时间项.月 == 3 && this->类中时间项.日 >= 21) || (this->类中时间项.月 == 4 && this->类中时间项.日 <= 19))
         {
            return C("白羊");
         }
         else if ((this->类中时间项.月 == 4 && this->类中时间项.日 >= 20) || (this->类中时间项.月 == 5 && this->类中时间项.日 <= 20))
         {
            return C("金牛");
         }
         else if ((this->类中时间项.月 == 5 && this->类中时间项.日 >= 21) || (this->类中时间项.月 == 6 && this->类中时间项.日 <= 21))
         {
            return C("双子");
         }
         else if ((this->类中时间项.月 == 6 && this->类中时间项.日 >= 22) || (this->类中时间项.月 == 7 && this->类中时间项.日 <= 22))
         {
            return C("巨蟹");
         }
         else if ((this->类中时间项.月 == 7 && this->类中时间项.日 >= 23) || (this->类中时间项.月 == 8 && this->类中时间项.日 <= 22))
         {
            return C("狮子");
         }
         else if ((this->类中时间项.月 == 8 && this->类中时间项.日 >= 23) || (this->类中时间项.月 == 9 && this->类中时间项.日 <= 22))
         {
            return C("处女");
         }
         else if ((this->类中时间项.月 == 9 && this->类中时间项.日 >= 23) || (this->类中时间项.月 == 10 && this->类中时间项.日 <= 22))
         {
            return C("天秤");
         }
         else if ((this->类中时间项.月 == 10 && this->类中时间项.日 >= 23) || (this->类中时间项.月 == 11 && this->类中时间项.日 <= 21))
         {
            return C("天蝎");
         }
         else
         {
            return C("射手");
         }
      }

      /**
       * \brief >>> 获取当前日期的生肖字符。
       * 
       * \return 字符。
       */
      constexpr 类型字符 获取生肖() const noexcept
      {
         constexpr 类型字符 生肖表[] = { C('猴'),C('鸡'),C('狗'),C('猪'),C('鼠'),C('牛'),C('虎'),C('兔'),C('龙'),C('蛇'),C('马'),C('羊') };

         return 生肖表[this->类中时间项.年 % 12];
      }

      /**
       * \brief >>> 根据当前日期获取星期。
       * 
       * \return 范围 0 - 6 的整数。
       */
      constexpr 类型日期 获取星期() const noexcept
      {
         return 时间集::推算星期(this->类中时间项.年, this->类中时间项.月, this->类中时间项.日);
      }

      /**
       * \brief >>> 不完全的判断两个时间对象，如只判断年月日相同，或者只判断年月等等。
       * 
       * \param 比较项： 要比较的对象。
       * \param 枚举项： 要比较的范围，如月则比较年和月是否相同。
       * \return 相同则返回真，否则返回假。
       */
      constexpr 类型逻辑 不完全判断(const 时间类 &比较项, 时间枚举 枚举项) const noexcept
      {
         for (时间枚举 迭代量 = 时间枚举::年; 迭代量 <= 枚举项 && 迭代量 != 时间枚举::结束; 迭代量 = static_cast<时间枚举>(static_cast<T::U8>(迭代量) + 1))
         {
            T::U8 索引值 = static_cast<T::U8>(迭代量);

            if (reinterpret_cast<const 类型时间 *>(&this->类中时间项)[索引值] != reinterpret_cast<const 类型时间 *>(&比较项.类中时间项)[索引值])
            {
               return 假;
            }
         }

         return 真;
      }

      protected:

      时间结构 类中时间项;

      public:

      // 使当前时间戳加上目标时间戳并重新推算时间。
      constexpr 时间类 &operator += (类型时间 时间戳项) noexcept
      {
         return this->赋值(this->类中时间项.总时间 + 时间戳项);
      }

      // 使当前时间戳减去目标时间戳并重新推算时间。
      constexpr 时间类 &operator -= (类型时间 时间戳项) noexcept
      {
         return this->赋值(this->类中时间项.总时间 - 时间戳项);
      }

   };

   // 将时间类转换为字符串的特化。
   template<>
   struct 转字符串类<时间类>
   {
      /**
       * \brief >>> 将时间按照指定格式转换为字符串，格式化中标记以 % 开始，有如下格式化标记：
       * \brief >>> %N 年份 %Y 月份 %R 日期 %S 时钟 %E 12 小时制时钟 %F 分钟 %M 秒钟 %H 毫秒
       * \brief >>> %T 总天数 %X 星期 %W 上/下午标识 %Q 时区偏移量 %q 时区名称 %s 生肖 %x 星座。
       *
       * \param 转换项： 要转换的对象。
       * \param 格式化项： 格式化字符串，默认为 "%N%s年%Y月%R日 %X (%Q)%S:%F:%M.%H %x座"。
       * \return 格式化后的字符串。
       */
       字符串类 operator () (const 时间类 &转换项, 字符视图类 格式化项 = C("%N%s年%Y月%R日 %X (%Q)%S:%F:%M.%H %x座")) noexcept
       {
          字符串类 返回值;
          // 类型字符 存储转换串[128];
          本地信息类 &本地信息 = 本地信息类::获取实例();
          类型字符 *转换结束 = 空指针;
          const 时间结构 &时间值 = 转换项.获取结构();

          for (auto 迭代量 = 格式化项.begin(); 迭代量 != 格式化项.end(); 迭代量++)
          {
             switch (*迭代量)
             {
                case C('%'): {
                   if (迭代量 + 1 != 格式化项.end())
                   {
                      switch (*++迭代量)
                      {
                         case C('N'):
                            返回值 << 时间值.年;
                            break;
                         case C('Y'):
                            返回值 << 字符串类(时间值.月).从左填充(2, C('0'));
                            break;
                         case C('R'):
                            返回值 << 字符串类(时间值.日).从左填充(2, C('0'));
                            break;
                         case C('S'):
                            返回值 << 字符串类(时间值.时).从左填充(2, C('0'));
                            break;
                         case C('E'):
                            返回值 << 字符串类(时间值.时 % 12).从左填充(2, C('0'));
                            break;
                         case C('F'):
                            返回值 << 字符串类(时间值.分).从左填充(2, C('0'));
                            break;
                         case C('M'):
                            返回值 << 字符串类(时间值.秒).从左填充(2, C('0'));
                            break;
                         case C('H'):
                            返回值 << 字符串类(时间值.毫秒).从左填充(3, C('0'));
                            break;
                         case C('T'):
                            返回值 << 字符串类(时间值.总天数).从左填充(3, C('0'));
                            break;
                         case C('X'):
                            返回值 << 本地信息.星期名称[转换项.获取星期()];
                            break;
                         case C('W'):
                            返回值 << (时间值.时 >= 12 ? 本地信息.上午标识 : 本地信息.下午标识);
                            break;
                         case C('Q'): {
                            auto 时区值 = 数学集::向近舍入((T::FMAX)(时间集::获取本地时间戳() - 时间集::获取标准时间戳()) / 时间集::除秒时 / 60.0 / 60.0);

                            返回值 << (时区值 > 0 ? C('+') : C('-'));
                            返回值 << 字符串类((T::UMAX)数学集::绝对值(时区值) * 100).从左填充(4, C('0'));
                         } break;
                         case C('q'):
                            返回值 << std::chrono::get_tzdb().current_zone()->name();
                            break;
                         case C('s'):
                            返回值 << 转换项.获取生肖();
                            break;
                         case C('x'):
                            返回值 << 转换项.获取星座();
                            break;
                         default:
                            返回值 << C('%') << *迭代量;
                      }
                   }
                   else
                   {
                      返回值 << C('%');
                   }
                } break;

                default:
                   返回值 << *迭代量;
             }
          }

          return 返回值;
       }
   };

   namespace 格式化集 {

      template<>
      struct 格式化类<时间类>
      {
         static 字符串类 格式化(数据管理类 &数据项, 类型长度 &当前索引项, 字符视图类 样式表项, 调用类 &调用项) noexcept
         {
            const 时间类 &时间值 = *reinterpret_cast<const 时间类 *>(数据项.获取句柄(当前索引项++)->类中指针);

            if (样式表项.非空的())
            {
               return ::BE::转字符串类<时间类>()(时间值, 样式表项);
            }

            return ::BE::转字符串类<时间类>()(时间值);
         }
      };

   }

}
