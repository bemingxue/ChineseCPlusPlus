
namespace BE {

   /**
    * \brief >>> 一种管理连续存储的字符串的视图可迭代类型，注意不要让脱离的字符串对象被销毁后继续使用。
    * \brief >>> 提供查找、比较的操作，并且支持区分大小写进行匹配。
    */
   struct 字符视图类 : 视图类<const 类型字符>
   {
      // 启用全局运算符。
      using EGO = void;

      // 基类的别名。
      using 类中基类 = 视图类<const 类型字符>;

      // 默认构造函数，总是将视图设置为空字符串而非空指针，默认区分大小写。
      字符视图类(类型逻辑 大小写区分否 = 真) noexcept : 类中基类(C(""), 0), 大小写区分(大小写区分否)
      {
      
      }

      // 以目标的字符串的指定长度的字符区间为视图，如果长度项为默认值则函数将自动计算长度。
      字符视图类(字符串类型<类型字符> auto &&赋值项, 类型长度 长度项 = 到末尾, 类型逻辑 大小写区分否 = 真) noexcept : 类中基类(), 大小写区分(大小写区分否)
      {
         this->赋值(赋值项, 长度项);
      }

      /**
       * \brief >>> 以目标的字符串的指定长度的字符区间为视图。
       * 
       * \param 赋值项： 要赋值的字符串对象。
       * \param 长度项： 要作为视图的字符长度，如果为默认值则函数将自动计算长度。
       * \return this &
       */
      字符视图类 &赋值(字符串类型<类型字符> auto &&赋值项, 类型长度 长度项 = 到末尾) noexcept /* 覆写视图类的赋值函数 */
      {
         this->类中指针 = ::BE::获取字符串(赋值项);
         this->类中长度 = 长度项 == 到末尾 ? ::BE::获取字符串长度(赋值项) : 长度项;
         return *this;
      }

      /**
       * \brief >>> 从左开始裁剪视图，直到遇到第一个不满足调用项的字符为止。
       * 
       * \param 调用项： 可调用对象，默认为所有空白字符。
       * \return this &
       * \tparam TmpCall： 可调用类型，至少接受一个类型字符参数并且返回值类型可以转换为类型逻辑。
       */
      template<调用返回类型<类型逻辑, 类型字符> TmpCall = 类型逻辑(*)(类型字符)>
      字符视图类 &从左裁剪(TmpCall &&调用项 = ::BE::字符集::是空白字符) noexcept(noexcept(安全调用类型<TmpCall, 类型字符>))
      {
         for (auto 迭代量 = this->类中指针; 迭代量 != this->类中指针 + this->类中长度; ++迭代量)
         {
            if (调用项(*迭代量) == 假)
            {
               this->类中长度 -= 迭代量 - this->类中指针;
               this->类中指针 = 迭代量;
               return *this;
            }
         }

         this->类中指针 += this->类中长度;
         this->类中长度 = 0;
         return *this;
      }

      /**
       * \brief >>> 从右开始裁剪视图，直到遇到第一个不满足调用项的字符为止。
       * 
       * \param 调用项： 可调用对象，默认为所有空白字符。
       * \return this &
       * \tparam TmpCall： 可调用类型，至少接受一个类型字符参数并且返回值类型可以转换为类型逻辑。
       */
      template<调用返回类型<类型逻辑, 类型字符> TmpCall = 类型逻辑(*)(类型字符)>
      字符视图类 &从右裁剪(TmpCall &&调用项 = ::BE::字符集::是空白字符) noexcept(noexcept(安全调用类型<TmpCall, 类型字符>))
      {
         for (; this->类中长度 != 0 && 调用项(*(this->类中指针 + this->类中长度 - 1)); --this->类中长度);
         return *this;
      }

      /**
       * \brief >>> 将当前视图以指定字符串为分隔符切割为多个子视图，并将这些子视图存入给定的容器中，注意两个连续紧贴在一起的分割符不会切割出一个空视图，也不会减少次数项。
       * 
       * \param 容器项： 要存储子视图的容器对象。
       * \param 分割项： 要作为分隔符的字符视图，如果为空视图则函数无作为。
       * \param 次数项： 要切割的次数，指定切割函数最多会切割的次数，有可能会比此项指定的少，但绝对不会多。
       * \param 截取末尾否： 指定如果次数项为 0，但还有余下的字符视图，是否将余下的字符视图作为一个整体的子视图存入容器中。
       * \return 容器项 &
       * \tparam TmpT： 可以使用 插入 函数插入字符视图类的容器类型。
       */
      template<可增加容器类型<字符视图类> TmpT>
      TmpT &切割(TmpT &容器项, 字符视图类 分割项, 类型长度 次数项 = 到末尾, 类型逻辑 截取末尾否 = false)
      noexcept(noexcept(requires() { 容器项.插入(字符视图类()); }))
      {
         类型长度 索引值 = 0;
         类型长度 分割项长度 = 分割项.类中长度;
         字符视图类 当前视图 = *this;

         if (分割项长度 == 0)
         {
            return 容器项;
         }

         while ((索引值 = 当前视图.查找子串(分割项)) != 到末尾 && 次数项 != 0)
         {
            // 判断是否是两个连续的分割符。
            if (索引值 != 0)
            {
               容器项.插入(字符视图类(当前视图, 索引值));
               次数项 -= 1;
            }

            当前视图(分割项长度 + 索引值);
         }

         if (当前视图.获取长度() != 0 && (次数项 != 0 || 截取末尾否))
         {
            容器项.插入(当前视图);
         }

         return 容器项;
      }

      /**
       * \brief >>> 查找字符视图中指定字符的位置。
       * 
       * \param 查找项： 要查找的字符。
       * \return 字符在视图中第一次出现的位置，如果没有则返回到末尾。
       */
      类型长度 查找字符(类型字符 查找项) const noexcept
      {
         return ::BE::查找(this->begin(), this->end(), 查找项, std::bind_front(&字符视图类::字符匹配, *this)).索引;
      }

      /**
       * \brief >>> 在字符视图中查找指定子字符串的位置。
       * 
       * \param 查找项： 要查找的字符串对象。
       * \return 字符串在视图中第一次出现的位置，如果没有则返回到末尾。
       */
      类型长度 查找子串(字符串类型<类型字符> auto &&查找项) const noexcept
      {
         return ::BE::查找块(this->begin(), this->end(), ::BE::获取字符串(查找项), ::BE::获取字符串(查找项) + ::BE::获取字符串长度(查找项), std::bind_front(&字符视图类::字符匹配, *this)).索引;
      }
      
      /**
       * \brief >>> 判断当前视图中的字符串是否与目标字符串类型中的字符串相等。
       * 
       * \param 比较项： 要比较的字符串对象。
       * \return 相等返回真，否则返回假。
       */
      类型逻辑 相等判断(字符串类型<类型字符> auto &&比较项) const noexcept
      {
         return ::BE::相等(this->begin(), this->end(), ::BE::获取字符串(比较项), ::BE::获取字符串(比较项) + ::BE::获取字符串长度(比较项), std::bind_front(&字符视图类::字符匹配, *this));
      }

      /**
       * \brief >>> 比较当前视图中的字符串与目标字符串类型中的字符串，首先比较长度，如果长度相同则比较他们的哈希值，不受区分大小写影响。
       * 
       * \param 比较项： 要比较的字符串对象。
       * \return 当前视图中的字符串等于目标字符串时返回零，小于返回小于零的值，大于返回大于零的值。
       */
      类型比较 比较判断(字符串类型<类型字符> auto &&比较项) const noexcept
      {
         类型长度 比较项长度 = ::BE::获取字符串长度(比较项);

         if (this->类中长度 != 比较项长度)
         {
            return this->类中长度 < 比较项长度 ? -1 : 1;
         }

         auto 左哈希 = ::BE::获取字符串哈希(*this);
         auto 右哈希 = ::BE::获取字符串哈希(比较项);

         return ::BE::比较(左哈希, 右哈希);
      }

      // 以目标的字符串为视图。
      字符视图类 &operator = (字符串类型<类型字符> auto &&赋值项) noexcept
      {
         return this->赋值(赋值项);
      }

      // 是否区分大小写来匹配字符的变量。
      类型逻辑 大小写区分 = 真;

      private:

      // 用于选择是否区分大小写来匹配字符的函数。
      类型逻辑 字符匹配(类型字符 左字符项, 类型字符 右字符项) const noexcept
      {
         return ::BE::字符集::字符相等(左字符项, 右字符项, this->大小写区分);
      }

      public:

      类型逻辑 operator == (const 字符视图类 &比较项) const noexcept
      {
         return this->相等判断(比较项);
      }

   };

}

namespace std {

   // 重载 std::hash 以支持字符视图类的哈希值计算。
   template<>
   struct hash<BE::字符视图类>
   {
      size_t operator () (const BE::字符视图类 &views) const noexcept
      {
         return ::BE::获取字符串哈希(views);
      }
   };
}

// 测试时输出使用。
#ifdef _BE_TEST_
std::ostream &operator << (std::ostream &os, const BE::字符视图类 &views)
{
   char32_t cstr[2] { };

   for (auto &it : views)
   {
      cstr[0] = it;
      os << std::filesystem::path(cstr).string();
   }

   return os;
}
#endif
