
namespace BE {

   /**
    * \brief >>> 将字符串中的的字符按照指定规则转换位指定类型的整数，不区分大小写，会自动跳过前缀。
    * 
    * \param 字符串项： 要转换的字符串。
    * \param 进制项： 字符串中的进制，默认为十进制，如果进制不在合法区间内则设置全局错误码并退出函数。
    * \param 调用项： 可调用对象，用于判断要跳过哪些字符，默认为所有空白字符。
    * \param 索引存储项： 如果不为空指针且进制无错误，则存储转换的末尾索引位置。
    * \return 转换出来的整数值。
    * \tparam TmpT： 指定整数类型，默认为 32 位整数类型，如果是无符号整数，则不会判断负号，意味如果存在负号，则不会发生任何转换。
    * \tparam TmpCall： 可调用类型，至少要接受一个字符类型参数并且返回值类型可以转换为类型逻辑。
    */
   template<整数类型 TmpT = 类型整数<>, 调用返回类型<类型逻辑, 类型字符> TmpCall = 类型逻辑(*)(类型字符)>
   inline TmpT 转为整数(字符视图类 字符串项, 类型进制 进制项 = 10, TmpCall &&调用项 = ::BE::字符集::是空白字符, 类型长度 *索引存储项 = 空指针) 
   noexcept(noexcept(安全调用类型<TmpCall, 类型字符>))
   {
      TmpT 返回值 { };
      TmpT 符号值 { 1 };
      类型无符<> 首计数值 { 0 };
      类型无符<> 分隔计数 { 0 };
      const 本地信息类 &本地化 = 本地信息类::获取实例();
      const 类型字符 *原指针位置 = 字符串项.begin();

      if (::BE::进制集::进制判断(进制项) == 假)
      {
         ::BE::错误码 = ::BE::错误集::进制错误;
         return 返回值;
      }

      // 跳过要跳过的字符并判断符号和前缀。
      字符串项.从左裁剪(调用项);
      字符串项(::BE::字符集::正负号判断(字符串项[0], &符号值));
      字符串项(::BE::进制集::具有前缀判断(进制项) && ::BE::进制集::进制前缀判断(进制项, 字符串项.begin(), 字符串项.获取长度()) ? ::BE::获取字符串长度(::BE::进制集::获取进制前缀(进制项)) : 0);

      while (字符串项 && (::BE::进制集::字符判断(进制项, 字符串项[0]) || (字符串项[0] == 本地化.数字分隔符 && 分隔计数 != 0)))
      {
         // 判断数字分隔符。
         if (字符串项[0] == 本地化.数字分隔符)
         {
            // 对于计数小于数字分隔位的清空，始终允许，如 "1'1234" 以及 "123'3456" 这种，第一个分隔符的位置肯定小于数字分隔位。
            if (分隔计数 <= 本地化.数字分隔位 && 首计数值 == 0)
            {
               // 获取第一个分隔符的位置。
               首计数值 = 分隔计数;
            }
            // 减去第一个分隔符的位置后取余判断，如果余数不为零则表示分隔符的位置不合法。
            else if ((分隔计数 - 首计数值) % 本地化.数字分隔位 != 0)
            {
               break;
            }
         }
         else
         {
            返回值 = 返回值 * 进制项 + ::BE::进制集::获取进制值(进制项, 字符串项[0]);
            分隔计数 += 1;
         }

         字符串项(1);
      }

      // 如果要的话，存储转换的末尾。
      if (索引存储项 != 空指针)
      {
         *索引存储项 = 字符串项.begin() - 原指针位置;
      }

      return 返回值 * 符号值;
   }

   /**
    * \brief >>> 将字符串中的的字符按照指定规则转换位指定类型的浮点数，不支持区分进制。
    * 
    * \param 字符串项： 要转换的字符串。
    * \param 调用项： 可调用对象，用于判断要跳过哪些字符，默认为所有空白字符。
    * \return 转换出来的浮点数值。
    * \tparam TmpT： 指定浮点类型，默认为 64 位浮点类型。
    * \tparam TmpCall： 可调用类型，至少要接受一个字符类型参数并且返回值类型可以转换为类型逻辑。
    */
   template<浮点类型 TmpT = 类型浮点<>, 调用返回类型<类型逻辑, 类型字符> TmpCall = 类型逻辑(*)(类型字符)>
   inline TmpT 转为浮点(字符视图类 字符串项, TmpCall &&调用项 = ::BE::字符集::是空白字符)
   noexcept(noexcept(安全调用类型<TmpCall, 类型字符>))
   {
      TmpT 返回值 { };
      TmpT 小数指数 { 10 };
      // 存储转换整数后的位置。
      类型长度 索引 { 0 };

      // 对于整数部分，直接调用整数转换函数。
      返回值 = static_cast<TmpT>(::BE::转为整数<T::IMAX>(字符串项, 10, 调用项, &索引));

      字符串项(索引);
      字符串项(字符串项[0] == L'.');

      while (字符串项 && ::BE::字符集::是数字字符(字符串项[0]))
      {
         返回值   += ::BE::获取符号(返回值) * ((字符串项[0] - C('0')) / 小数指数);
         小数指数 *= 10;

         字符串项(1);
      }

      return 返回值;
   }

}
