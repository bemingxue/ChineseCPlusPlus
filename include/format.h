
//#define 调用注册宏()

namespace BE {

   // { call ? args : style }

   namespace 错误集 {

      inline constexpr 类型错误 格式化后调错误 = C("格式化函数需要向后调取一个参数，但参数类型错误或没有！");

      inline constexpr 类型错误 格式化调用不存在错误 = C("调用表中要调用的函数不存在！");

      inline constexpr 类型错误 格式化调用参数索引 = C("调用表中函数期望获得参数，但参数错误或不存在！");

   }

   // 一些格式化函数所需要使用到的工具集合。
   namespace 格式化集 {

      enum class 基本字符枚举 : 类型字符
      {
         开始标记 = C('{'),
         结束标记 = C('}'),
         转义标记 = C('$'),
         样式标记 = C(':'),
         参数标记 = C('?'),
      };

      // 允许字符枚举能够与字符进行比较。
      inline constexpr 类型逻辑 operator == (基本字符枚举 左值项, 类型字符 右值项) noexcept
      {
         return static_cast<类型字符>(左值项) == 右值项;
      }

      /**
       * \brief >>> 判断字符串项是否为样式表的结束标记。
       * 
       * \param 字符串项： 要判断的字符串项。
       * \return 是则返回真，否则返回假。
       */
      inline 类型逻辑 样式表结束判断(const 字符视图类 &字符串项) noexcept
      {
         return !字符串项.非空的() || 字符串项[0] == 0 || 字符串项[0] == 基本字符枚举::结束标记;
      }

      // 格式化所可用设定的样式。
      struct 样式表类
      {
         static constexpr 类型字符 后缀补零符     = C('F');
         static constexpr 类型字符 二进制符       = C('B');                // 进制符的大小写影响大小写属性。
         static constexpr 类型字符 八进制符       = C('0');
         static constexpr 类型字符 十六进制符     = C('X');
         static constexpr 类型字符 前缀符         = C('?');                // 表示显示进制前缀（如果有的话）
         static constexpr 类型字符 小数符         = C('.');
         static constexpr 类型字符 分隔符         = C('\'');               // 表示启用分隔符策略。
         static constexpr 类型字符 后调符         = C('*');                // 表示宽度或精度由后面的一个参数决定。
         static constexpr 类型长度 后调标记       = 到末尾;                 // 宽度和精度指定为该值表示使用后面的一个参数决定。
         static constexpr 类型字符 可用正号符表[] = { C('+'), C(' ') };

         // style: {:^'+B?10.2f&}

         类型长度 总长度 = 0;
         类型长度 精度值 = 默认精度;
         类型字符 填充字符 = C(' ');
         类型字符 正号符 = 0;
         转换枚举 额外设定值 = 转换枚举{};
         类型进制 进制值 = 10;
         对齐枚举 对齐方式 = 对齐枚举::左对齐;
      };

      /* 负责解析样式表的函数，均不检查末尾 */

      inline 类型逻辑 解析对齐样式(字符视图类 &字符串项, 样式表类 &样式表项) noexcept
      {
         switch (字符串项[0])
         {
            case C('>'):
               样式表项.对齐方式 = 对齐枚举::右对齐;
               break;
            case C('<'):
               样式表项.对齐方式 = 对齐枚举::左对齐;
               break;
            case C('^'):
               样式表项.对齐方式 = 对齐枚举::居中对齐;
               break;
            default:
               return !样式表结束判断(字符串项);
         }

         字符串项(1);

         return !样式表结束判断(字符串项);
      }

      inline 类型逻辑 解析分隔样式(字符视图类 &字符串项, 样式表类 &样式表项) noexcept
      {
         if (字符串项[0] == 样式表类::分隔符)
         {
            样式表项.额外设定值 = 样式表项.额外设定值 | 转换枚举::启用分隔;
            字符串项(1);
         }

         return !样式表结束判断(字符串项);
      }

      inline 类型逻辑 解析正号样式(字符视图类 &字符串项, 样式表类 &样式表项) noexcept
      {
         for (auto &迭代量 : 样式表类::可用正号符表)
         {
            if (字符串项[0] == 迭代量)
            {
               样式表项.正号符 = 迭代量;
               字符串项(1);
               break;
            }
         }

         return !样式表结束判断(字符串项);
      }

      inline 类型逻辑 解析进制样式(字符视图类 &字符串项, 样式表类 &样式表项) noexcept
      {
         switch (字符集::转大写字母(字符串项[0]))
         {
            case 样式表类::二进制符:
               样式表项.进制值 = 2;
               break;
            case 样式表类::八进制符:
               样式表项.进制值 = 8;
               break;
            case 样式表类::十六进制符:
               样式表项.进制值 = 16;
               break;
            default:
               return !样式表结束判断(字符串项);
         }

         if (字符集::是小写字母(字符串项[0]))
         {
            样式表项.额外设定值 = 样式表项.额外设定值 | 转换枚举::小写显示;
         }

         字符串项(1);

         return !样式表结束判断(字符串项);
      }

      inline 类型逻辑 解析前缀样式(字符视图类 &字符串项, 样式表类 &样式表项) noexcept
      {
         if (字符串项[0] == 样式表类::前缀符)
         {
            样式表项.额外设定值 = 样式表项.额外设定值 | 转换枚举::前缀显示;
            字符串项(1);
         }
         return !样式表结束判断(字符串项);
      }

      inline 类型逻辑 解析宽度样式(字符视图类 &字符串项, 样式表类 &样式表项) noexcept
      {
         if (字符串项[0] == 样式表类::后调符)
         {
            样式表项.总长度 = 样式表类::后调标记;
            字符串项(1);
         }
         else if (字符集::是数字字符(字符串项[0]))
         {
            样式表项.总长度 = ::BE::转为整数<类型长度>(字符串项, 10);
            字符串项.从左裁剪(字符集::是数字字符);
         }

         return !样式表结束判断(字符串项);
      }

      inline 类型逻辑 解析精度样式(字符视图类 &字符串项, 样式表类 &样式表项) noexcept
      {
         if (字符串项[0] == 样式表类::小数符)
         {
            字符串项(1);

            if (样式表结束判断(字符串项))
            {
               样式表项.精度值 = 0;
            }
            else if (字符串项[0] == 样式表类::后调符)
            {
               样式表项.精度值 = 样式表类::后调标记;
               字符串项(1);
            }
            else if (字符集::是数字字符(字符串项[0]))
            {
               样式表项.精度值 = ::BE::转为整数<类型长度>(字符串项, 10);
               字符串项.从左裁剪(字符集::是数字字符);
            }
            else
            {
               样式表项.精度值 = 0;
            }
         }

         return !样式表结束判断(字符串项);
      }

      inline 类型逻辑 解析补零样式(字符视图类 &字符串项, 样式表类 &样式表项) noexcept
      {
         if (字符集::转大写字母(字符串项[0]) == 样式表类::后缀补零符)
         {
            样式表项.额外设定值 = 样式表项.额外设定值 | 转换枚举::补充零值;
            字符串项(1);
         }

         return !样式表结束判断(字符串项);
      }

      inline 类型逻辑 解析填充字符(字符视图类 &字符串项, 样式表类 &样式表项) noexcept
      {
         if (!样式表结束判断(字符串项))
         {
            样式表项.填充字符 = 字符串项[0];
            字符串项(1);
         }

         return !样式表结束判断(字符串项);
      }

      /**
       * \brief >>> 依次解析字符串中的对齐、分隔、正号、进制、前缀、宽度、精度、补零、填充字符等样式。
       * 
       * \param 字符串项： 要解析的字符串。
       * \param 样式表项： 存储解析结构的对象。
       * \return 如果解析完毕后还没有抵达样式表末尾，则返回多余的字符串，否则返回空字符串表示整个样式表解析完毕。
       */
      inline 字符视图类 解析样式字符串(字符视图类 字符串项, 样式表类 &样式表项) noexcept
      {
         类型逻辑(*解析函数表[])(字符视图类 &, 样式表类 &) noexcept = 
         { 
            解析对齐样式, 解析分隔样式, 解析正号样式, 解析进制样式, 解析前缀样式, 解析宽度样式, 解析精度样式, 解析补零样式, 解析填充字符 
         };

         for (auto &迭代函数 : 解析函数表)
         {
            if (迭代函数(字符串项, 样式表项) == 假)
            {
               break;
            }
         }

         if (!样式表结束判断(字符串项))
         {
            return 字符串项;
         }
         return 字符视图类();
      }

      // 格式化函数对于参数类型的分类。
      enum class 参数类型枚举 : unsigned char
      {
         句柄,
         短整数,           // short
         标准整数,         // int
         长整数,           // long
         长长整数,         // long long
         无符短整数,       // unsigned short
         无符标准整数,     // unsigned int
         无符长整数,       // unsigned long
         无符长长整数,     // unsigned long long
         短浮点数,         // float
         标准浮点数,       // double
         长浮点数,         // long double
         逻辑, 
         指针,
         字节,
         字符串,
         字符,
         窄字符,
         数组,             // 有边界数组，无边界数组属于指针一别。
      };

      /**
       * \brief >>> 该函数将指定类型分类为格式化函数所需的类型。
       * 
       * \return 分类后的类型。
       */
      template<typename TmpT>
      inline consteval 参数类型枚举 获取参数分类() noexcept
      {
         using TmpRe = std::remove_cvref_t<TmpT>;

         if constexpr (相同类型<TmpRe, short>)
         {
            return 参数类型枚举::短整数;
         }
         else if constexpr (相同类型<TmpRe, int>)
         {
            return 参数类型枚举::标准整数;
         }
         else if constexpr (相同类型<TmpRe, long>)
         {
            return 参数类型枚举::长整数;
         }
         else if constexpr (相同类型<TmpRe, long long>)
         {
            return 参数类型枚举::长长整数;
         }
         else if constexpr (相同类型<TmpRe, unsigned short>)
         {
            return 参数类型枚举::无符短整数;
         }
         else if constexpr (相同类型<TmpRe, unsigned int>)
         {
            return 参数类型枚举::无符标准整数;
         }
         else if constexpr (相同类型<TmpRe, unsigned long>)
         {
            return 参数类型枚举::无符长整数;
         }
         else if constexpr (相同类型<TmpRe, unsigned long long>)
         {
            return 参数类型枚举::无符长长整数;
         }
         else if constexpr (相同类型<TmpRe, float>)
         {
            return 参数类型枚举::短浮点数;
         }
         else if constexpr (相同类型<TmpRe, double>)
         {
            return 参数类型枚举::标准浮点数;
         }
         else if constexpr (相同类型<TmpRe, long double>)
         {
            return 参数类型枚举::长浮点数;
         }
         else if constexpr (相同类型<TmpRe, bool>)
         {
            return 参数类型枚举::逻辑;
         }
         else if constexpr (相同类型<TmpRe, 类型字节>)
         {
            return 参数类型枚举::字节;
         }
         else if constexpr (相同类型<TmpRe, 类型字符>)
         {
            return 参数类型枚举::字符;
         }
         else if constexpr (相同类型<TmpRe, char>)
         {
            return 参数类型枚举::窄字符;
         }
         else if constexpr (相同类型<TmpRe, 类型空值>)
         {
            return 参数类型枚举::指针;
         }
         else if constexpr (字符串类型<TmpRe, 类型字符>)
         {
            return 参数类型枚举::字符串;
         }
         else if constexpr (边界数组类型<TmpRe>)
         {
            return 参数类型枚举::数组;
         }
         else if constexpr (转换类型<std::add_const_t<模板退化类型<TmpRe>>, const void *>)
         {
            return 参数类型枚举::指针;
         }
         else
         {
            return 参数类型枚举::句柄;
         }
      }

      /**
       * \brief >>> 判断枚举项表示的是否为 short、int、long、long long 中的任一类型。
       * 
       * \param 枚举项： 要判断的枚举项。
       * \return 是则返回真，否则返回假。
       */
      inline constexpr 类型逻辑 分类有符整数判断(参数类型枚举 枚举项) noexcept
      {
         return 枚举项 == 参数类型枚举::短整数 || 枚举项 == 参数类型枚举::标准整数 ||
                枚举项 == 参数类型枚举::长整数 || 枚举项 == 参数类型枚举::长长整数;
      }

      /**
       * \brief >>> 判断枚举项表示的是否为 unsigned short、unsigned int、unsigned long、unsigned long long 中的任一类型。
       * 
       * \param 枚举项： 要判断的枚举项。
       * \return 是则返回真，否则返回假。
       */
      inline constexpr 类型逻辑 分类无符整数判断(参数类型枚举 枚举项) noexcept
      {
         return 枚举项 == 参数类型枚举::无符短整数 || 枚举项 == 参数类型枚举::无符标准整数 ||
                枚举项 == 参数类型枚举::无符长整数 || 枚举项 == 参数类型枚举::无符长长整数;
      }

      /**
       * \brief >>> 判断枚举项表示的是否为 float、double、long double 中的任一类型。
       * 
       * \param 枚举项： 要判断的枚举项。
       * \return 是则返回真，否则返回假。
       */
      inline constexpr 类型逻辑 分类浮点数判断(参数类型枚举 枚举项) noexcept
      {
         return 枚举项 == 参数类型枚举::短浮点数 || 枚举项 == 参数类型枚举::标准浮点数 ||
                枚举项 == 参数类型枚举::长浮点数;
      }

      /**
       * \brief >>> 判断枚举项是否是任意标准整数类型。
       * 
       * \param 枚举项： 要判断的枚举项。
       * \return 是则返回真，否则返回假。
       */
      inline constexpr 类型逻辑 分类整数判断(参数类型枚举 枚举项) noexcept
      {
         return 分类有符整数判断(枚举项) || 分类无符整数判断(枚举项);
      }

      /**
       * \brief >>> 判断枚举项是否为字符分类。
       * 
       * \param 枚举项： 要判断的枚举项。
       * \return 是则返回真，否则返回假。
       */
      inline constexpr 类型逻辑 分类字符判断(参数类型枚举 枚举项) noexcept
      {
         return 枚举项 == 参数类型枚举::字符 || 枚举项 == 参数类型枚举::窄字符;
      }
      
      struct 数据管理类;
      struct 调用类;
      
      // 如果类型需要被格式化，要么特化转字符串类，要么特化该类并实现格式化函数，通过特化该类允许你根据样式表自定义格式化方式，默认行为或调用转字符串类。
      template<typename STmpT>
      struct 格式化类
      {
         // 特化时不要生命该类型别名。
         using Default = void;

         static 字符串类 格式化(数据管理类 &数据项, 类型长度 &当前索引项, 字符视图类 样式表项, 调用类 &调用项) noexcept;
      };

      template<typename TmpT>
      concept 默认格式化类型 = requires() {
         typename 格式化类<TmpT>::Default;
      };

      // 一种 TmpT 类型可用被格式化的概念，即具有格式化类的特化或者转字符串类的特化的类型。
      template<typename TmpT, typename TmpU = std::remove_cvref_t<TmpT>>
      concept 可格式化类型 = ( 默认格式化类型<TmpU> && 可转字符串类型<TmpU>) || 数组类型<TmpU> ||
                            (!默认格式化类型<TmpU> && requires(数据管理类 & 数据项, 类型长度 & 当前索引项, 字符视图类 样式表项, 调用类 & 调用项) { { 格式化类<TmpU>::格式化(数据项, 当前索引项, 样式表项, 调用项) } -> 相同类型<字符串类>; });

      using 格式化函数 = 字符串类(*)(数据管理类 &, 类型长度 &, 字符视图类, 调用类 &) noexcept;

      // 存储额外类型的数据与信息。
      struct 句柄类
      {
         const void *类中指针;
         const 格式化函数 类中函数;

         template<typename TmpT>
         句柄类(TmpT &&获取项) noexcept
            : 类中指针(&获取项)
            , 类中函数(格式化类<std::remove_cvref_t<TmpT>>::格式化) /* 不能因为实例化了 int 但却因为 TmpT 为 int & 而实例化失败 */
         {
            static_assert(可格式化类型<TmpT>, "The type cannot be formatted - 类型不可格式化");
         }

      };

      // 对于数组，存储其数据和长度信息。
      struct 数组类
      {
         const void     *类中指针;
         const 类型长度   类中长度;
         const 格式化函数 类中函数;

         template<typename TmpT>
         数组类(TmpT &&数组项) noexcept
            : 类中指针(&数组项)
            , 类中长度(::std::size(数组项))
            , 类中函数(格式化类<TmpT>::格式化)
         {
            static_assert(可格式化类型<std::remove_reference_t<模板解引类型<TmpT>>>, "The type cannot be formatted - 类型不可格式化");
         }
      };

      /**
       * \brief >>> 根据类型分类，将指定对象转换为对应的可存储类型。
       * 
       * \param 获取项： 要获取的对象。
       * \return 存储对象的值。
       */
      template<typename TmpT>
      inline auto 获取数据(TmpT &&获取项) noexcept
      {
         if constexpr (获取参数分类<TmpT>() == 参数类型枚举::句柄)
         {
            return 句柄类 { 获取项 };
         }
         else if constexpr (获取参数分类<TmpT>() == 参数类型枚举::数组)
         {
            return 数组类 { 获取项 };
         }
         else if constexpr (获取参数分类<TmpT>() == 参数类型枚举::字符串)
         {
            return 字符视图类{ ::BE::获取字符串(获取项), ::BE::获取字符串长度(获取项) };
         }
         else
         {
            return 获取项;
         }
      }

      /**
       * \brief >>> 获取 TmpT 分类后的类型占用字节数。
       * 
       * \return 占用字节数。
       */
      template<typename TmpT>
      inline consteval 类型长度 获取长度() noexcept
      {
         return sizeof(获取数据<TmpT>(std::declval<TmpT>()));
      }

      // 存储索引和类型信息的类。
      struct 索引类
      {
         类型长度     索引值;
         参数类型枚举 类型值;
      };

      // 抹除了类型信息的类，负责管理数据并将数据转换。
      struct 数据管理类
      {
         类型字节 *数据值;
         索引类   *索引值;
         const 类型长度 总长度;
         const 类型长度 总占用;

         // 简便获取类型信息的下标调用。
         参数类型枚举 operator [] (类型长度 索引项) noexcept
         {
            return this->索引值[索引项].类型值;
         }

         // 将指定位置的数据块看作有符号整数，并将其转换后返回，如果数据块不是任意有符号整数则返回 0。
         T::IMAX 获取有符整数(类型长度 索引项) const noexcept
         {
            类型长度   位置值 = this->索引值[索引项].索引值;
            参数类型枚举 类别 = this->索引值[索引项].类型值;

            if (类别 == 参数类型枚举::短整数)
            {
               return static_cast<T::IMAX>(*reinterpret_cast<const short *>(this->数据值 + 位置值));
            }
            else if (类别 == 参数类型枚举::标准整数)
            {
               return static_cast<T::IMAX>(*reinterpret_cast<const int *>(this->数据值 + 位置值));
            }
            else if (类别 == 参数类型枚举::长整数)
            {
               return static_cast<T::IMAX>(*reinterpret_cast<const long *>(this->数据值 + 位置值));
            }
            else if (类别 == 参数类型枚举::长长整数)
            {
               return static_cast<T::IMAX>(*reinterpret_cast<const long long * > (this->数据值 + 位置值));
            }

            return T::IMAX{};
         }

         // 将指定位置的数据块看作无符号整数，并将其转换后返回，如果数据块不是任意无符号整数则返回 0。
         T::UMAX 获取无符整数(类型长度 索引项) const noexcept
         {
            类型长度   位置值 = this->索引值[索引项].索引值;
            参数类型枚举 类别 = this->索引值[索引项].类型值;

            if (类别 == 参数类型枚举::无符短整数)
            {
               return static_cast<T::UMAX>(*reinterpret_cast<const unsigned short *>(this->数据值 + 位置值));
            }
            else if (类别 == 参数类型枚举::无符标准整数)
            {
               return static_cast<T::UMAX>(*reinterpret_cast<const unsigned int *>(this->数据值 + 位置值));
            }
            else if (类别 == 参数类型枚举::无符长整数)
            {
               return static_cast<T::UMAX>(*reinterpret_cast<const unsigned long *>(this->数据值 + 位置值));
            }
            else if (类别 == 参数类型枚举::无符长长整数)
            {
               return static_cast<T::UMAX>(*reinterpret_cast<const unsigned long long *> (this->数据值 + 位置值));
            }

            return T::UMAX{};
         }

         // 将指定位置的数据块看作浮点数，并将其转换后返回，如果数据块不是任意浮点数则返回 0。
         T::FMAX 获取浮点数(类型长度 索引项) const noexcept
         {
            类型长度   位置值 = this->索引值[索引项].索引值;
            参数类型枚举 类别 = this->索引值[索引项].类型值;

            if (类别 == 参数类型枚举::短浮点数)
            {
               return static_cast<T::FMAX>(*reinterpret_cast<const float *>(this->数据值 + 位置值));
            }
            else if (类别 == 参数类型枚举::标准浮点数)
            {
               return static_cast<T::FMAX>(*reinterpret_cast<const double *>(this->数据值 + 位置值));
            }
            else if (类别 == 参数类型枚举::长浮点数)
            {
               return static_cast<T::FMAX>(*reinterpret_cast<const long double *>(this->数据值 + 位置值));
            }

            return T::FMAX{};
         }

         // 将指定位置的数据块看作为一个句柄类，并将其转换后返回，函数不检查类型是否正确。
         const 句柄类 *获取句柄(类型长度 索引项) const noexcept
         {
            return reinterpret_cast<const 句柄类 *>(this->数据值 + this->索引值[索引项].索引值);
         }

         // 将指定位置的数据块看作为一个数组类，并将其转换后返回，函数不检查类型是否正确。
         const 数组类 *获取数组(类型长度 索引项) const noexcept
         {
            return reinterpret_cast<const 数组类 *>(this->数据值 + this->索引值[索引项].索引值);
         }

         // 将指定位置的数据块看作逻辑，并将其转换后返回，函数不检查类型是否正确。
         bool 获取逻辑(类型长度 索引项) const noexcept
         {
            return *reinterpret_cast<const bool *>(this->数据值 + this->索引值[索引项].索引值);
         }

         // 将指定位置的数据块看作指针，并将其转换后返回，函数不检查类型是否正确。
         const void *获取指针(类型长度 索引项) const noexcept
         {
            // return reinterpret_cast<const void *>(this->数据值 + this->索引值[索引项].索引值);
            // error： 获取存储指针的值而不是存储指针的对象的地址。

            return *reinterpret_cast<const void **>(this->数据值 + this->索引值[索引项].索引值);
         }

         // 将指定位置的数据块看作字节，并将其转换后返回，函数不检查类型是否正确。
         类型字节 获取字节(类型长度 索引项) const noexcept
         {
            return *reinterpret_cast<const 类型字节 *>(this->数据值 + this->索引值[索引项].索引值);
         }

         // 将指定位置的数据块看作字符视图类，并将其转换后返回，函数不检查类型是否正确。
         字符视图类 获取视图(类型长度 索引项) const noexcept
         {
            return *reinterpret_cast<const 字符视图类 *>(this->数据值 + this->索引值[索引项].索引值);
         }

         // 将指定位置的数据块看作字符，并将其转换后返回，函数不检查类型是否正确。
         类型字符 获取字符(类型长度 索引项) const noexcept
         {
            return *reinterpret_cast<const 类型字符 *>(this->数据值 + this->索引值[索引项].索引值);
         }

         // 将指定位置的数据块看作窄字符，并将其转换后返回，函数不检查类型是否正确。
         char 获取窄字符(类型长度 索引项) const noexcept
         {
            return *reinterpret_cast<const char *>(this->数据值 + this->索引值[索引项].索引值);
         }
      };

      // 负责将多个参数使用特殊方式存储到一块连续的内存空间中，并记录每个参数的位置和类型。
      template<typename... STmpArgs>
      struct 数据存储类
      {
         static constexpr 类型长度 总长度 = sizeof...(STmpArgs);
         static constexpr 类型长度 总占用 = (获取长度<STmpArgs>() + ... + 0);

         数据存储类(const STmpArgs&... 参数表) noexcept
         {
            类型长度 索引值 = 0;

            // 第一个参数在内存块中的开始位置永远是 0。
            this->类中索引[0].索引值 = 0;
           (this->存储数据(参数表, 索引值++), ...);
         }

         /**
          * \brief >>> 函数获取一个擦除了类型信息的管理数据的类型。
          * 
          * \return 管理数据的类型。
          */
         数据管理类 获取管理() noexcept
         {
            return 数据管理类 { this->类中存储, this->类中索引, 总长度, 总占用 };
         }

         protected:
         类型字节 类中存储[总占用];
         索引类   类中索引[总长度];

         template<typename TmpT>
         类型空的 存储数据(TmpT &&数据项, 参数类型枚举 类型项, 类型长度 索引项) noexcept
         {
            类型长度 前索引 = this->类中索引[索引项].索引值;

            // 直接将数据按字节存储到内存块中。
            std::memcpy(this->类中存储 + 前索引, &数据项, sizeof(TmpT));

            this->类中索引[索引项].类型值 = 类型项;

            // 如果不是最后一个参数则计算下一个参数的开始位置。
            if (索引项 + 1 < 总长度)
            {
               this->类中索引[索引项 + 1].索引值 = 前索引 + sizeof(TmpT);
            }
         }

         template<typename TmpT>
         类型空的 存储数据(TmpT &&数据项, 类型长度 索引项) noexcept
         {
            this->存储数据(获取数据(std::forward<TmpT>(数据项)), 获取参数分类<TmpT>(), 索引项);
         }
      };

      // 对于没有参数的特化。
      template<>
      struct 数据存储类<>
      {
         static constexpr 类型长度 总长度 = 0;
         static constexpr 类型长度 总占用 = 0;

         数据存储类() noexcept = default;

         数据管理类 获取管理() noexcept
         {
            return 数据管理类 { nullptr, nullptr, 总长度, 总占用 };
         }
      };

      inline 字符串类 选择格式化(数据管理类 &, 类型长度 &, 字符视图类, 调用类 &) noexcept; 
      inline 类型逻辑 后调捕获(数据管理类 &, 类型长度 &, 样式表类 &, 调用类 &) noexcept;

      /**
       * \brief >>> 一个维护全局格式化调用函数的类，只允许一个实例存在。
       * \brief >>> 默认注册了如下函数：
       * \brief >>> 1. i(参数索引)：格式化指定索引位置的参数。
       * \brief >>> 2. set： 使用样式表中的数据修改默认样式表，对于 set 后调将被用于修改样式表而非直接将样式表中的宽度和精度修改为后调。
       */
      struct 调用类 : 错误类
      {
         using 字符键类 = 字符视图类;
         using 调用函数 = 字符串类(*)(数据管理类 &, 类型长度 &, 字符视图类, 字符视图类, 调用类 &);
         using 调用表类 = std::unordered_map<字符键类, 调用函数, std::hash<字符键类>>;

         样式表类 默认样式表;

         /**
          * \brief >>> 获取唯一的调用表。
          * 
          * \return 调用表的引用。
          */
         static 调用类 &获取唯一实例() noexcept
         {
            static 调用类 全局唯一实例;
            static 类型逻辑 注册否 = 假;

            if (注册否 == 假)
            {
               注册否 = 真;

               全局唯一实例.注册调用(C("i"), 调用类::调用指定);
               全局唯一实例.注册调用(C("set"), 调用类::调用样式);
            }

            return 全局唯一实例;
         }

         /**
          * \brief >>> 在调用表中查找指定名称的函数是否被注册，如果注册则返回函数，否则返回空指针。
          * 
          * \param 调用名项： 要查找的函数名称。
          * \return 查找结果，空指针或函数的函数指针。
          */
         调用函数 查找调用(字符键类 调用名项) noexcept
         {
            auto 结果值 = this->类中表.find(调用名项.从左裁剪());

            if (结果值 == this->类中表.end())
            {
               return 空指针;
            }
            return 结果值->second;
         }

         /**
          * \brief >>> 注册一个指定名称的函数指针到调用表中。
          * 
          * \param 调用名项： 要注册的函数名称，如果存在已注册的则设置错误并退出函数，名字为空则不执行注册，函数会裁剪名字最左边的所有空白字符。
          * \param 调用项： 要注册的函数指针，其参数包括：数据管理类 &、类型长度 &、字符视图类、字符视图类、调用类 &，第一个字符视图参数为参数项。
          * \return 
          */
         类型空的 注册调用(字符键类 调用名项, 调用函数 调用项) noexcept
         {
            if (this->查找调用(调用名项.从左裁剪()) != 空指针)
            {
               this->设置错误(::BE::错误集::重复错误);
               return;
            }

            if (!调用名项.非空的())
            {
               return;
            }

            this->类中表[调用名项] = 调用项;
         }

         ~调用类() noexcept = default;

         private:
         调用表类 类中表;

         调用类() noexcept = default;
         调用类(const 调用类 &) noexcept = delete;
         调用类(调用类 &&) noexcept = delete;
         调用类 &operator=(const 调用类 &) noexcept = delete;
         调用类 &operator=(调用类 &&) noexcept = delete;

         static 字符串类 调用指定(数据管理类 &数据项, 类型长度 &当前索引项, 字符视图类 参数项, 字符视图类 样式表项, 调用类 &调用项) noexcept
         {
            字符串类 返回值;

            if (参数项.非空的() == 假 || !字符集::是数字字符(参数项[0]))
            {
               调用项.设置错误(错误集::格式化调用参数索引);
               return 返回值;
            }

            类型长度 索引值 = ::BE::转为整数<类型长度>(参数项);
            返回值 = 选择格式化(数据项, 索引值, 样式表项, 调用项);

            return 返回值;
         }

         static 字符串类 调用样式(数据管理类 &数据项, 类型长度 &当前索引项, 字符视图类 参数项, 字符视图类 样式表项, 调用类 &调用项) noexcept
         {
            样式表类 样式表 = 调用项.默认样式表;

            解析样式字符串(样式表项, 样式表);

            if (后调捕获(数据项, 当前索引项, 样式表, 调用项) == 假)
            {
               return 字符串类{};
            }

            调用项.默认样式表 = 样式表;

            return 字符串类{};
         }

      };

      inline const 调用类 *调用唯一实例 = &调用类::获取唯一实例();

      // 判断样式表中的宽度、精度是否需要后调，如果需要则向后调用整数类型参数进行补充，如果没有参数或者参数类型错误则设置错误后返回假。
      inline 类型逻辑 后调捕获(数据管理类 &数据项, 类型长度 &当前索引项, 样式表类 &样式表项, 调用类 &调用项) noexcept
      {
         if (样式表项.总长度 == 样式表类::后调标记)
         {
            if (当前索引项 < 数据项.总长度 && 分类整数判断(数据项[当前索引项]))
            {
               样式表项.总长度 = 分类有符整数判断(数据项[当前索引项]) ? 数据项.获取有符整数(当前索引项) : 数据项.获取无符整数(当前索引项);
               当前索引项 += 1;
            }
            else
            {
               调用项.设置错误(错误集::格式化后调错误);
               return 假;
            }
         }

         if (样式表项.精度值 == 样式表类::后调标记)
         {
            if (当前索引项 < 数据项.总长度 && 分类整数判断(数据项[当前索引项]))
            {
               样式表项.精度值 = 分类有符整数判断(数据项[当前索引项]) ? 数据项.获取有符整数(当前索引项) : 数据项.获取无符整数(当前索引项);
               当前索引项 += 1;
            }
            else
            {
               调用项.设置错误(错误集::格式化后调错误);
               return 假;
            }
         }

         return 真;
      }

      // 负责对除了句柄、数组外的类型进行格式化操作。
      inline 字符串类 默认格式化(数据管理类 &数据项, 类型长度 &当前索引项, 字符视图类 样式表项, 调用类 &调用项) noexcept
      {
         字符串类 返回值;
         类型长度 起始索引 = 当前索引项;
         样式表类 样式表 = 调用项.默认样式表;

         解析样式字符串(样式表项, 样式表);

         if (后调捕获(数据项, ++当前索引项, 样式表, 调用项) == 假)
         {
            当前索引项 = 起始索引;
            return 返回值;
         }

         if (分类有符整数判断(数据项[起始索引]))
         {
            返回值 = ::BE::转字符串类<T::IMAX>()(数据项.获取有符整数(起始索引), 样式表.进制值, 样式表.正号符, 样式表.额外设定值);
         }
         else if (分类无符整数判断(数据项[起始索引]))
         {
            返回值 = ::BE::转字符串类<T::UMAX>()(数据项.获取无符整数(起始索引), 样式表.进制值, 样式表.正号符, 样式表.额外设定值);
         }
         else if (分类浮点数判断(数据项[起始索引]))
         {
            返回值 = ::BE::转字符串类<T::FMAX>()(数据项.获取浮点数(起始索引), 样式表.精度值, 样式表.进制值, 样式表.正号符, 样式表.额外设定值);
         }
         else if (数据项[起始索引] == 参数类型枚举::字符串)
         {
            返回值 = 数据项.获取视图(起始索引);
         }
         else if (数据项[起始索引] == 参数类型枚举::字符)
         {
            返回值 = 数据项.获取字符(起始索引);
         }
         else if (数据项[起始索引] == 参数类型枚举::逻辑)
         {
            返回值 = ::BE::转字符串类<bool>()(数据项.获取逻辑(起始索引));
         }
         else if (数据项[起始索引] == 参数类型枚举::窄字符)
         {
            返回值 = static_cast<类型字符>(数据项.获取窄字符(起始索引));
         }
         else if (数据项[起始索引] == 参数类型枚举::字节)
         {
            返回值 = ::BE::转字符串类<类型字节>()(数据项.获取字节(起始索引));
         }
         else if (数据项[起始索引] == 参数类型枚举::指针)
         {
            返回值 = ::BE::转字符串类<const void *>()(数据项.获取指针(起始索引));
         }
         // 不存在 else
         else
         {

         }

         // 是字符分类且具有字符不进行格式化的设定则直接返回。
         if (!::BE::掩码判断(样式表.额外设定值, 转换枚举::字符格式) && 分类字符判断(数据项[起始索引]))
         {
            return 返回值;
         }

         // 宽度如果为 0 则表示无需对齐。
         if (样式表.总长度 != 0)
         {
            ::BE::字符串对齐(返回值, 样式表.总长度, 样式表.填充字符, 样式表.对齐方式);
         }

         return 返回值;
      }

      template<typename STmpT>
      inline 字符串类 BE::格式化集::格式化类<STmpT>::格式化(数据管理类 &数据项, 类型长度 &当前索引项, 字符视图类 样式表项, 调用类 &调用项) noexcept
      {
         字符串类 返回值;
         类型长度 起始索引 = 当前索引项;
         样式表类 样式表 = 调用项.默认样式表;

         解析样式字符串(样式表项, 样式表);

         if (后调捕获(数据项, ++当前索引项, 样式表, 调用项) == 假)
         {
            当前索引项 = 起始索引;
            return 返回值;
         }

         if constexpr (!数组类型<STmpT>)
         {
            using 实际类 = std::remove_cvref_t<STmpT>;

            返回值 = ::BE::转字符串类<实际类>()(*reinterpret_cast<const 实际类 *>(数据项.获取句柄(起始索引)->类中指针));
         }
         // 数组则获取 [var1, var2, var3... ] 形式的字符串并且不参与格式化，这也包括 STmpT 为整数等类型时。 
         else
         {
            using 解引类 = std::remove_reference_t<模板解引类型<STmpT>>;

            const 数组类 *数组值 = 数据项.获取数组(起始索引);
            const 类型字节 *指针值 = reinterpret_cast<const 类型字节 *>(数组值->类中指针);

            返回值 << C("[ ");

            for (类型长度 索引量 = 0; 索引量 < 数组值->类中长度; ++索引量, 指针值 += sizeof(解引类))
            {
               数据存储类 存储值 { *reinterpret_cast<const 解引类 *>(指针值) };
               数据管理类 数据管理 = 存储值.获取管理();
               类型长度   索引值 = 0;
               返回值 << 选择格式化(数据管理, 索引值, C(""), 调用项);

               if (索引量 + 1 < 数组值->类中长度)
               {
                  返回值 << C(", ");
               }
            }

            return 返回值 << C(" ]");
         }

         // 宽度如果为 0 则表示无需对齐。
         if (样式表.总长度 != 0)
         {
            ::BE::字符串对齐(返回值, 样式表.总长度, 样式表.填充字符, 样式表.对齐方式);
         }

         return 返回值;
      }

      // 根据数据类型选择调用格式化函数。
      inline 字符串类 选择格式化(数据管理类 &数据项, 类型长度 &当前索引项, 字符视图类 样式表项, 调用类 &调用项) noexcept
      {
         if (数据项[当前索引项] == 参数类型枚举::句柄)
         {
            return 数据项.获取句柄(当前索引项)->类中函数(数据项, 当前索引项, 样式表项, 调用项);
         }
         else if (数据项[当前索引项] == 参数类型枚举::数组)
         {
            return 数据项.获取数组(当前索引项)->类中函数(数据项, 当前索引项, 样式表项, 调用项);
         }
         else
         {
            return 默认格式化(数据项, 当前索引项, 样式表项, 调用项);
         }
      }

      // 特化对于本函数库中的所有序列容器类型。
      template<typename STmpT>
      requires(requires() { typename STmpT::标准数组标识; })
      struct 格式化类<STmpT>
      {
         using 解引类 = std::remove_reference_t<模板解引类型<模板迭代类型<STmpT>>>;

         static 字符串类 格式化(数据管理类 &数据项, 类型长度 &当前索引项, 字符视图类 样式表项, 调用类 &调用项) noexcept
         {
            const STmpT *对象指针 = reinterpret_cast<const STmpT *>(数据项.获取句柄(当前索引项++)->类中指针);
            字符串类 返回值;

            返回值 << C("[ ");

            for (auto &&[索引量, 迭代量] : 列举迭代类(*对象指针))
            {
               数据存储类 存储值 { 迭代量 };
               数据管理类 数据管理 = 存储值.获取管理();
               类型长度   索引值 = 0;
               返回值 << 选择格式化(数据管理, 索引值, C(""), 调用项);

               if (索引量 + 1 < ::BE::获取长度(*对象指针))
               {
                  返回值 << C(", ");
               }
            }

            return 返回值 << C(" ]");
         }
      };

      // 从字符串中截取出普通的字符串，并移动截取项。
      inline 字符视图类 截取普通串(字符视图类 &截取项) noexcept
      {
         类型长度 截取长度 = 0;

         while (截取项.非空的() && 截取长度 < 截取项.获取长度() && 截取项[截取长度] != 基本字符枚举::开始标记 && 截取项[截取长度] != 基本字符枚举::转义标记)
         {
            截取长度++;
         }

         字符视图类 返回值{ 截取项, 截取长度 };
         截取项(截取长度, 到末尾);
         return 返回值;
      }

      // 从截取项中截取特殊串 {...} 中的调用名称、参数以及格式化表，如果没有对应的部分则不设置。
      inline 类型空的 截取特殊串(字符视图类 &截取项, 字符视图类 &调用名项, 字符视图类 &参数项, 字符视图类 &格式化表项) noexcept
      {
         enum : T::U8 
         {
            截取在名称, 截取在参数, 截取在样式
         };

         // 判断当前正在截取那个部分。
         T::U8 截取定位 = 截取在名称;
         类型长度 子截取长度 = 0;

         // 跳过 "{"
         截取项(1);

         // 循环判断截取。
         while (!样式表结束判断(截取项.截取(子截取长度, 到末尾)))
         {
            // 遇到一次标记后后面的标记字符都不再作数，如遇到一次 ? 了那么后面的所有 ? 都不再做此处理，因此允许如 {:???} 等方式。
            if (截取项[子截取长度] == 基本字符枚举::参数标记 && 截取定位 < 截取在参数)
            {
               调用名项 = 截取项.从左截取(子截取长度);
               // 加 1 负责跳过标记。
               截取项(子截取长度 + 1);
               子截取长度 = 0;
               截取定位 = 截取在参数;
            }

            else if (截取项[子截取长度] == 基本字符枚举::样式标记 && 截取定位 < 截取在样式)
            {
               (截取定位 == 截取在参数 ? 参数项 : 调用名项) = 截取项.从左截取(子截取长度);
               截取项(子截取长度 + 1);
               子截取长度 = 0;
               截取定位 = 截取在样式;
            }
            
            else
            {
               子截取长度 += 1;
            }
         }

         // 最后一次截取时可能既没有遇到参数也没有遇到样式等等，因此这里需要判断一下。
         (截取定位 == 截取在样式 ? 格式化表项 : (截取定位 == 截取在参数 ? 参数项 : 调用名项)) = 截取项.从左截取(子截取长度);
         截取项(子截取长度 + 1);
      }

   }

   /**
    * \brief >>> 函数根据格式化项中的字符串进行格式化操作，对于普通字符串原样传参到调用项中，对于 $$ 传递 $，对于 ${...} 传递 {...}。函数使用 {...} 表示格式化操作，可用指定已经注册的调用函数或者格式化参数表的参数。
    * \brief >>> {...} 基本格式如下： {调用名称?调用参数:样式表}
    * \brief >>> 如果指定调用名称，则函数将在调用类中的注册表中寻找指定的调用项，并将调用函数的返回值传参到调用项中，如果没有指定，则采取将参数表中的第 n 个参数格式化的操作。
    * \brief >>> 注意，调用函数可修改 n，并且每次格式化时也都会让 n + 1。
    * \brief >>> 参与格式化的参数类型要么具有转字符串类的特化，要么特化格式化集中的格式化类，并实现格式化静态成员函数。 
    * \brief >>> 进行默认格式化操作中的样式表格式如下： ^>< 对齐 ' 启用分隔 +  正号 BX0 进制 ? 显示前缀 (数字或*) 宽度 (.数字或*) 精度 f 填充小数零 & 任意合法填充字符。
    * 
    * \param 格式化项： 指明格式化形式的字符串。
    * \param 调用项： 可调用对象，负责接受每次格式化函数处理的结果。
    * \param 参数表： 格式化或额外参数。
    * \return 调用类实例，格式化函数每次都会清除调用类实例中的错误信息，并将格式化过程中的新错误信息返回。
    * \tparam TmpCall： 可调用类型，要能接受一个字符视图类参数。
    * \tparam TmpArgs： 参数表中的参数类型。
    */
   template<调用类型<字符视图类> TmpCall, typename... TmpArgs>
   格式化集::调用类 &格式化(字符视图类 格式化项, TmpCall &&调用项, const TmpArgs&... 参数表) noexcept
   {
      格式化集::调用类 &调用实例 = 格式化集::调用类::获取唯一实例();
      格式化集::数据存储类 存储值 { 参数表... };
      格式化集::数据管理类 数据管理 = 存储值.获取管理();

      类型长度 当前索引 = 0;
      字符串类 结果串;
      字符视图类 存储串;

      调用实例.重置错误();

      while ((存储串 = 格式化集::截取普通串(格式化项)) || 格式化项.非空的())
      {
         if (存储串.非空的())
         {
            调用项(存储串);
         }
         else
         {
            switch (static_cast<格式化集::基本字符枚举>(格式化项[0]))
            {
               case 格式化集::基本字符枚举::转义标记: {

                  // 对于 $$ 情况获取 $，${...} 情况获取 {。
                  if (格式化项.获取长度() > 1 && (格式化项[1] == 格式化集::基本字符枚举::转义标记 || 格式化项[1] == 格式化集::基本字符枚举::开始标记))
                  {
                     存储串 = 格式化项.截取(1, 1);
                     格式化项(2);
                  }
                  // 对于 $ 后不跟 $ 或 { 的情况获取 $。
                  else
                  {
                     存储串 = 格式化项.从左截取(1);
                     格式化项(1);
                  }

                  调用项(存储串);

               } break;

               default: {

                  字符视图类 调用名;
                  字符视图类 参数;
                  字符视图类 格式化表;

                  格式化集::截取特殊串(格式化项, 调用名, 参数, 格式化表);

                  // 去除调用名称的左边所有空白字符。
                  调用名.从左裁剪();

                  if (调用名.非空的())
                  {
                     if (auto 调用 = 调用实例.查找调用(调用名); 调用 != 空指针)
                     {
                        结果串 = 调用(数据管理, 当前索引, 参数, 格式化表, 调用实例);
                     }
                     else
                     {
                        调用实例.设置错误(::BE::错误集::格式化调用不存在错误);
                        continue;
                     }
                  }
                  else
                  {
                     结果串 = 格式化集::选择格式化(数据管理, 当前索引, 格式化表, 调用实例);
                  }

                  // 返回的结果为空则不进行调用。
                  if (结果串.非空的())
                  {
                     调用项(结果串);
                  }

               } break;
            }
         }
      }

      return 调用实例;
   }

   /**
    * \brief >>> 调用格式化函数将格式化结果整合到一个字符串中并将其返回，如果期间格式化出现了任意错误则返回空字符串。
    * 
    * \param 格式化项： 指明格式化形式的字符串。
    * \param 参数表： 格式化或额外参数。
    * \return 格式化结果字符串。
    * \tparam TmpArgs： 参数表中的参数类型。
    */
   template<typename... TmpArgs>
   字符串类 格式化串(字符视图类 格式化项, const TmpArgs&... 参数表) noexcept
   {
      字符串类 返回值;

      auto &调用实例 = 格式化(格式化项, [&返回值](字符视图类 字符串项) { 返回值 << 字符串项; }, 参数表...);
   
      if (调用实例)
      {
         return 返回值;
      }
      return C("");
   }

}
