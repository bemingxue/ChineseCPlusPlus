
#include "./Pri/_chars.h"

namespace BE {

   /**
    * \brief >>> 根据判断项是否为非数、无穷来返回对应的特殊字符串，如果都不是则返回空字符串。
    * 
    * \param 判断项： 要判断的数值。
    * \return 只读字符指针。
    */
   template<浮点类型 TmpT>
   inline const 类型字符 *获取浮点特殊串(TmpT 判断项) noexcept
   {
      if (::BE::数学集::非数判断(判断项))
      {
         return 本地信息类::获取实例().非数表示;
      }
      else if (::BE::数学集::无限判断(判断项))
      {
         return 本地信息类::获取实例().无穷表示;
      }
      else
      {
         return C("");
      }
   }

   /**
    * \brief >>> 获取指定整数按照指定方式转换位字符串所需要的空间长度。
    * 
    * \param 转换项： 要转换的整数。
    * \param 进制项： 要转换的进制。
    * \param 正号项： 要显示的正号，如果为结束符则表示不显示。
    * \param 额外设定项： 转换选项，详细见转换枚举。
    * \return 所需的长度，如果进制错误则返回 0 并设置全局错误码。
    * \tparam TmpT： 任意满足整数类型要求的类型。
    */
   template<严格整数类型 TmpT>
   inline 类型长度 获取转为字符流长度(TmpT 转换项, 类型进制 进制项 = 10, 类型字符 正号项 = C('\0'), 转换枚举 额外设定项 = 转换枚举{}) noexcept
   {
      if (!::BE::进制集::进制判断(进制项))
      {
         ::BE::错误码 = ::BE::错误集::进制错误;
         return 0;
      }

      类型长度 返回值 = ::BE::进制集::获取进制长度(进制项, 转换项);
      const 本地信息类 &本地化 = ::BE::本地信息类::获取实例();

      if (返回值 != 0)
      {
         // 如果数字长度刚好等于分隔位则不需要额外分隔符。
         if (::BE::掩码判断(额外设定项, ::BE::转换枚举::启用分隔) && 本地化.数字分隔位 != 0 && 返回值 != 本地化.数字分隔位)
         {
            类型长度 分隔数 = 返回值 / 本地化.数字分隔位;

            分隔数 -= (分隔数 != 0 && (返回值 % 本地化.数字分隔位 == 0));
            返回值 += 分隔数;
         }

         if (::BE::掩码判断(额外设定项, ::BE::转换枚举::前缀显示))
         {
            返回值 += ::BE::获取长度(::BE::进制集::获取进制前缀(进制项, !::BE::掩码判断(额外设定项, ::BE::转换枚举::小写显示)));
         }

         if (转换项 < 0 || 正号项 != C('\0'))
         {
            返回值 += 1;
         }
      }

      return 返回值;
   }

   /**
    * \brief >>> 将指定整数类型按照指定方式转换为字符串并存储到指定的字符流中，函数保证相同的转换条件下，其转换成功的结果总是能够被 `转为整数` 函数解析回对应的整数。
    * 
    * \param 开始项： 字符流开始位置，如果字符流无符存储转换后的字符串则函数转换失败。
    * \param 结束项： 字符流结束位置。
    * \param 转换项： 要转换的整数。
    * \param 进制项： 要转换的进制，如果不是合法进制则设置全局错误码并转换失败。
    * \param 正号项： 要显示的正号，如果为结束符则表示不显示。
    * \param 额外设定项： 转换选项，详细见转换枚举。
    * \return 转换成功则返回转换后字符串的最后一个成员的后一个位置的指针，否则返回开始项。
    * \tparam TmpT： 任意满足整数类型要求的类型。
    */
   template<严格整数类型 TmpT>
   inline 类型字符 *转为字符流(类型字符 *开始项, 类型字符 *结束项, TmpT 转换项, 类型进制 进制项 = 10, 类型字符 正号项 = L'\0', 转换枚举 额外设定项 = 转换枚举{}) noexcept
   {
      类型长度 计数值 = 0;
      类型长度 长度值 = ::BE::获取转为字符流长度(转换项, 进制项, 正号项, 额外设定项);
      类型字符 *开始位置 = 开始项;
      const 本地信息类 &本地化 = ::BE::本地信息类::获取实例();

      if (static_cast<类型长度>(结束项 - 开始项) >= 长度值 && 长度值 != 0)
      {
         if (转换项 < 0)
         {
            *开始项++ = C('-');
         }
         else if (正号项 != C('\0'))
         {
            *开始项++ = 正号项;
         }

         if (::BE::掩码判断(额外设定项, ::BE::转换枚举::前缀显示))
         {
            decltype(auto) 前缀字符串 = ::BE::进制集::获取进制前缀(进制项, !::BE::掩码判断(额外设定项, ::BE::转换枚举::小写显示));
            类型长度 前缀长度 = ::BE::获取长度(前缀字符串);

            ::BE::复制(开始项, 前缀字符串, 前缀字符串 + 前缀长度);
            开始项 += 前缀长度;
         }

         转换项 = ::BE::数学集::绝对值(转换项);

         // 直接倒序转换，避免转换完成后还要翻转。
         for (类型字符 *迭代量 = 开始位置 + 长度值 - 1; 迭代量 != 开始项 - 1; --迭代量)
         {
            if (::BE::掩码判断(额外设定项, ::BE::转换枚举::启用分隔) && 计数值 != 0 && 计数值 % 本地化.数字分隔位 == 0)
            {
               *迭代量 = 本地化.数字分隔符;
               计数值 = 0;
            }
            else
            {
               类型字符 字符 = ::BE::进制集::进制字符表[转换项 % 进制项];

               if (::BE::掩码判断(额外设定项, ::BE::转换枚举::小写显示))
               {
                  字符 = ::BE::字符集::转小写字母(字符);
               }

               * 迭代量 = 字符;
               ++计数值;
               转换项 /= 进制项;
            }
         }

         return 开始位置 + 长度值;
      }

      return 开始项;
   }

   /**
    * \brief >>> 函数获取指定浮点数转换为字符串所需要的长度，函数判断特殊值，如非数、无穷。
    * 
    * \param 转换项： 要转换的浮点数。
    * \param 精度项： 要显示的精度，即小数位数，你可以指定一个很大的数，在没有设定 `补充零值` 的情况下，函数会自动在合适的位置停止。
    * \param 进制项： 要转换的进制，如果不是合法进制则设置全局错误码并转换失败。
    * \param 正号项： 要显示的正号，如果为结束符则表示不显示。
    * \param 额外设定项： 转换选项，详细见转换枚举。
    * \return 所需的长度，如果进制错误则返回 0 并设置全局错误码。
    * \tparam TmpT： 任意浮点数类型。
    */
   template<浮点类型 TmpT>
   inline 类型长度 获取转为字符流长度(TmpT 转换项, 类型长度 精度项 = 默认精度, 类型进制 进制项 = 10, 类型字符 正号项 = C('\0'), 转换枚举 额外设定项 = 转换枚举{}) noexcept
   {
      // 先判断是不是特殊值。
      const 类型字符 *字符串 = ::BE::获取浮点特殊串(转换项);
      
      if (字符串[0] != C('\0'))
      {
         return ::BE::获取长度(字符串) + (正号项 != C('\0') || ::BE::数学集::负数判断(转换项));
      }

      类型长度 返回值 = ::BE::获取转为字符流长度(static_cast<T::IMAX>(转换项), 进制项, 正号项, 额外设定项);
      类型长度 小数长度 = 0;

      if (返回值 != 0 && 精度项 != 0)
      {
         if (::BE::掩码判断(额外设定项, ::BE::转换枚举::补充零值))
         {
            返回值 += 精度项 + 1;
         }
         else
         {
            转换项 = ::BE::数学集::绝对值(转换项 -= static_cast<T::IMAX>(转换项));

            // 如果后面连续三位小数都是 0 则结束循环。
            while (!X::R::IsDecimalZeroCount(转换项, 进制项, 连续零检查) && 小数长度 < 精度项 && 小数长度 < 最大精度)
            {
               转换项 = 转换项 * 进制项 - static_cast<T::IMAX>(转换项 * 进制项);
               小数长度++;
            }
         }
      }

      // 加上小数点的长度。
      return 返回值 + (小数长度 != 0) + 小数长度;
   }

   /**
    * \brief >>> 函数将指定浮点数转为字符串，将其中每个字符存入开始项表示的字符流中。
    * 
    * \param 开始项： 字符流开始位置，如果字符流无符存储转换后的字符串则函数转换失败。
    * \param 结束项： 字符流结束位置。
    * \param 转换项： 要转换的浮点数，可以是非数、无穷、-0 等特殊值。
    * \param 精度项： 要显示的精度，即小数位数，你可以指定一个很大的数，在没有设定 `补充零值` 的情况下，函数会自动在合适的位置停止。
    * \param 进制项： 要转换的进制，如果不是合法进制则设置全局错误码并转换失败。
    * \param 正号项： 要显示的正号，如果为结束符则表示不显示。
    * \param 额外设定项： 转换选项，详细见转换枚举。
    * \return 转换后字符串的最后一个成员的后一个位置的指针，如果转换失败则返回开始项。
    * \tparam TmpT： 任意浮点数类型。
    */
   template<浮点类型 TmpT>
   inline 类型字符 *转为字符流(类型字符 *开始项, 类型字符 *结束项, TmpT 转换项, 类型长度 精度项 = 默认精度, 类型进制 进制项 = 10, 类型字符 正号项 = L'\0', 转换枚举 额外设定项 = 转换枚举{}) noexcept
   {
      类型长度  长度值   = ::BE::获取转为字符流长度(转换项, 精度项, 进制项, 正号项, 额外设定项);
      类型长度  小数长度 = 0;
      类型字符 *开始位置 = 开始项;

      const 类型字符 *字符串 = ::BE::获取浮点特殊串(转换项);

      if (static_cast<类型长度>(结束项 - 开始项) >= 长度值 && 长度值 != 0)
      {
         // 使用更严谨的方式判断负数。
         if (::BE::数学集::负数判断(转换项))
         {
            *开始项++ = C('-');
         }
         else if (正号项 != C('\0'))
         {
            *开始项++ = 正号项;
         }

         // 判断是否为特殊值，是的话则直接复制即可。
         if (字符串[0] != C('\0'))
         {
            类型长度 特殊长度 = ::BE::获取长度(字符串);

            ::BE::复制(开始项, 字符串, 字符串 + 特殊长度);
            开始项 += 特殊长度;
         }
         else
         {
            // 由于先判断了正负，因此这里需要转为绝对值，让转为字符流函数不添加负号。
            转换项 = ::BE::数学集::绝对值(转换项);
            开始项 = ::BE::转为字符流(开始项, 结束项, static_cast<T::IMAX>(转换项), 进制项, C('\0'), 额外设定项);
            转换项 = ::BE::数学集::分解浮点(转换项).小数;

            // 判断是否具有小数。
            if (精度项 != 0 && (::BE::掩码判断(额外设定项, ::BE::转换枚举::补充零值) || !::BE::X::R::IsDecimalZeroCount(转换项, 进制项, 连续零检查)))
            {
               *开始项++ = C('.');

               while ((!::BE::X::R::IsDecimalZeroCount(转换项, 进制项, 连续零检查) || ::BE::掩码判断(额外设定项, ::BE::转换枚举::补充零值)) && 小数长度 < 精度项 && 小数长度 < 最大精度)
               {
                  转换项 = 转换项 * 进制项;
                  *开始项++ = ::BE::进制集::进制字符表[static_cast<T::IMAX>(转换项)];
                  转换项 -= static_cast<T::IMAX>(转换项);

                  小数长度++;
               }
            }
         }
      }
      
      return 开始项;
   }
}
