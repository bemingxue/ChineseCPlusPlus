
#include "./Pri/_times.h"

namespace BE {

   using 类型时间 = T::UMAX;
   using 类型日期 = T::U16;

   // 一个表示年月日、时分秒、毫秒、总秒数的结构体。
   struct 时间结构
   {
      类型日期 年;
      类型日期 月;
      类型日期 日;
      类型日期 时;
      类型日期 分;
      类型日期 秒;
      类型日期 毫秒;
      类型日期 总天数;      // 从当前年到指定日期的总天数。
      类型时间 总时间;      // 总的时间戳。
   };

   // 一些基本的时间处理工具集合。
   namespace 时间集 {

      // 标准计时器所表示的起始年份。
      inline constexpr 类型日期 起始年份 = 1970;

      // 当前系统的计时器表示的起始年份。
      inline constexpr 类型日期 系统起始年 = 1601;

      inline constexpr 类型日期 平年月份表[] = { 31,28,31,30,31,30,31,31,30,31,30,31 };

      inline constexpr 类型日期 平年月推表[] = { 0,31,59,90,120,151,181,212,243,273,304,334 };

      // 时间转换为秒数所需要除的常数。
      inline constexpr 类型时间 除秒时 = X::R::STLTimerDuration::period::den;

      /**
       * \brief >>> 将目标时间戳进行本地化处理。
       * 
       * \param 时间戳项： 目标时间戳。
       * \return 本地化完成后的时间戳。
       */
      inline 类型时间 本地化时间戳(类型时间 时间戳项) noexcept
      {
         return static_cast<类型时间>(std::chrono::duration_cast<X::R::STLTimerDuration>(std::chrono::zoned_time(
            std::chrono::get_tzdb().current_zone(), 
            X::R::STLTimerPoint(X::R::STLDuration(X::R::STLTimerDuration(时间戳项)))
         ).get_local_time().time_since_epoch()).count());
      }

      /**
       * \brief >>> 获取当前系统的标准时间戳。
       * 
       * \return 系统标准时间戳。
       */
      inline 类型时间 获取标准时间戳() noexcept
      {
         return static_cast<类型时间>(std::chrono::duration_cast<X::R::STLTimerDuration>(X::R::STLClock::now().time_since_epoch()).count());
      }

      /**
       * \brief >>> 获取当前本地化后的时间戳。
       * 
       * \return 本地化后的时间戳。
       */
      inline 类型时间 获取本地时间戳() noexcept
      {
         return 本地化时间戳(获取标准时间戳());
      }

      /**
       * \brief >>> 判断给定的年份是否为闰年。
       * 
       * \param 年份项： 要判断的年份。
       * \return 是则返回真，否则返回假。
       */
      inline constexpr 类型逻辑 闰年判断(类型日期 年份项) noexcept
      {
         return (年份项 % 4 == 0 && 年份项 % 100!= 0) || 年份项 % 400 == 0;
      }
      
      /**
       * \brief >>> 获取指定年份中的指定月份的总天数，判断闰年。
       * 
       * \param 年份项： 月份所在的年份。
       * \param 月份项： 要获取的月份，从 1 开始。
       * \return 该月的总天数。
       */
      inline constexpr 类型日期 获取月份(类型日期 年份项, 类型日期 月份项) noexcept
      {
         return 平年月份表[月份项 - 1] + (月份项 == 2 && 闰年判断(年份项));
      }

      /**
       * \brief >>> 获取指定年份中要到达指定月份所需的天数。
       * 
       * \param 年份项： 月份所在的年份。
       * \param 月份项： 要获取的月份，从 1 开始。
       * \return 到达该月的天数。
       */
      inline constexpr 类型日期 获取月份起始(类型日期 年份项, 类型日期 月份项) noexcept
      {
         return 平年月推表[月份项 - 1] + (月份项 > 2 && 闰年判断(年份项));
      }

      /**
       * \brief >>> 推算从指定年份的开始到目标日期的总天数。
       * 
       * \param 年份项： 目标日期所在的年份。
       * \param 月份项： 目标日期所在的月份。
       * \param 天数项： 目标日期的天数。
       * \return 从指定年份的开始到目标日期的总天数。
       */
      inline constexpr 类型日期 推算已过天数(类型日期 年份项, 类型日期 月份项, 类型日期 天数项) noexcept
      {
         return 365 * 年份项 + (年份项 / 4) - (年份项 / 100) + (年份项 / 400) + ((月份项 * 306 + 5) / 10) + (天数项 - 1);
      }

      /**
       * \brief >>> 根据年月日推算该年月日的星期。
       * 
       * \param 年份项： 月份所在的年份。
       * \param 月份项： 月份值，从 1 开始。
       * \param 天数项： 月份中的天数。
       * \return 星期， 以 0 表示星期天。
       */
      inline constexpr 类型日期 推算星期(类型日期 年份项, 类型日期 月份项, 类型日期 天数项) noexcept
      {
         return (月份项 == 1 || 月份项 == 2 ? (月份项 += 12, 年份项 -= 1) : 0), ((天数项 + 2 * 月份项 + 3 * (月份项 + 1) / 5 + 年份项 + 年份项 / 4 - 年份项 / 100 + 年份项 / 400) % 7);
      }

      /**
       * \brief >>> 函数依据给定的起始年份判断传入的时间是否合法有效。
       * 
       * \param 判断项： 要判断的时间结构体。
       * \param 起始年项： 起始年份。
       * \return 合法则返回真，否则返回假。
       */
      inline constexpr 类型逻辑 日期有效判断(const 时间结构 &判断项, 类型日期 起始年项 = 起始年份) noexcept
      {
         return 判断项.年 >= 起始年项 && 判断项.月 >= 1 && 判断项.月 <= 12 && 判断项.日 >= 1 && 判断项.日 <= 获取月份(判断项.年, 判断项.月) && 
                判断项.时 >= 0 && 判断项.时 < 24 && 判断项.分 >= 0 && 判断项.分 < 60 && 判断项.秒 >= 0 && 判断项.秒 < 60 && 判断项.毫秒 >= 0 && 判断项.毫秒 < 1000;
      }

      /**
       * \brief >>> 从时间结构中通过年、月、日、时、分、秒，并依据起始年份推算时间戳。
       * 
       * \param 时间项： 要推算的时间结构体。
       * \param 起始年项： 起始年份。
       * \return 时间戳。
       */
      inline constexpr 类型时间 推算总秒(const 时间结构 &时间项, 类型日期 起始年项 = 起始年份) noexcept
      {
         类型时间 返回值 = 0;

         if (日期有效判断(时间项, 起始年项) == 假)
         {
            return 0;
         }

         返回值 += 时间项.时 * 3600ull + 时间项.分 * 60ull + 时间项.秒 + (时间项.日 - 1ull) * 86400ull;

         for (类型日期 年份项 = 起始年份; 年份项 < 时间项.年; 年份项++)
         {
            返回值 += (365ull + (闰年判断(年份项))) * 86400;
         }

         for (类型日期 月份项 = 1; 月份项 < 时间项.月; 月份项++)
         {
            返回值 += 获取月份(时间项.年, 月份项) * 86400ull;
         }

         return 返回值 * 除秒时;
      }

      /**
       * \brief >>> 将时间戳转换为存储年月日等信息的时间结构。
       * 
       * \param 时间戳项： 要转换的时间戳。
       * \param 起始年项： 起始的年份。
       * \return 存储年月日等信息的时间结构。
       */
      inline constexpr 时间结构 解析时间戳(类型时间 时间戳项, 类型日期 起始年项 = 时间集::起始年份) noexcept
      {
         时间结构 返回值{ };

         返回值.总时间 = 时间戳项;
         返回值.毫秒   = 时间戳项 / 1000 % 1000;
         返回值.年     = 起始年项;

         时间戳项 /= 除秒时;

         while (时间戳项 >= 365 * 86400ull)
         {
            类型逻辑 闰年 = 闰年判断(返回值.年);

            if (时间戳项 >= (365ull + 闰年) * 86400)
            {
               时间戳项 -= (365ull + 闰年) * 86400;
               返回值.年 += 1;
            }
            else
            {
               break;
            }
         }

         返回值.总天数 = static_cast<类型日期>(时间戳项 / 86400ull);

         时间戳项 %= 86400ull;

         返回值.时 = static_cast<类型日期>(时间戳项 / 3600ull);
         返回值.分 = static_cast<类型日期>(时间戳项 % 3600ull) / 60ull;
         返回值.秒 = static_cast<类型日期>(时间戳项 % 60ull);

         返回值.月 = 返回值.总天数 >= 获取月份起始(返回值.年, 12) ? 12 :
                    返回值.总天数 >= 获取月份起始(返回值.年, 11) ? 11 :
                    返回值.总天数 >= 获取月份起始(返回值.年, 10) ? 10 :
                    返回值.总天数 >= 获取月份起始(返回值.年,  9) ? 9  :
                    返回值.总天数 >= 获取月份起始(返回值.年,  8) ? 8  :
                    返回值.总天数 >= 获取月份起始(返回值.年,  7) ? 7  :
                    返回值.总天数 >= 获取月份起始(返回值.年,  6) ? 6  :
                    返回值.总天数 >= 获取月份起始(返回值.年,  5) ? 5  :
                    返回值.总天数 >= 获取月份起始(返回值.年,  4) ? 4  :
                    返回值.总天数 >= 获取月份起始(返回值.年,  3) ? 3  :
                    返回值.总天数 >= 获取月份起始(返回值.年,  2) ? 2  : 1;

         返回值.日 = 返回值.总天数 - 获取月份起始(返回值.年, 返回值.月) + 1;

         return 返回值;
      }
   }

   

}
