
namespace BE {

   /**
    * \brief >>> 提供一种能够预设格式化样式的类型，并通过调用运算符将任意可转字符串类型对象转换为字符串并存储和返回。
    */
   struct 对象字符串类
   {
      struct 样式表类 : 数字字符串类::样式表类
      {
         类型长度 总长度;
         类型字符 填充字符;
         对齐枚举 对齐方式;

         样式表类(类型长度 总长度项 = 0, 类型字符 填充字符 = C(' '), 对齐枚举 对齐项 = 对齐枚举::左对齐,
              类型进制 进制项 = 10, 类型长度 精度项 = 默认精度, 类型字符 正号项 = C('\0'), 转换枚举 额外设定项 = 转换枚举{ }) noexcept
            : 总长度(总长度项)
            , 填充字符(填充字符)
            , 对齐方式(对齐项)
         {
            this->进制值 = 进制项;
            this->精度值 = 精度项;
            this->正号值 = 正号项;
            this->额外设定值 = 额外设定项;
         }
      };

      样式表类 样式表;

      // 预设样式表的构造函数。
      对象字符串类(类型长度 总长度项 = 0, 类型字符 填充字符 = C(' '), 对齐枚举 对齐项 = 对齐枚举::左对齐,
             类型进制 进制项 = 10, 类型长度 精度项 = 默认精度, 类型字符 正号项 = C('\0'), 转换枚举 额外设定项 = 转换枚举{ }) noexcept
      {
         this->样式表 = 样式表类(总长度项, 填充字符, 对齐项, 进制项, 精度项, 正号项, 额外设定项);
      }

      // 赋值目标样式表。
      对象字符串类(const 对象字符串类 &赋值项) noexcept
      {
         this->样式表 = 赋值项.样式表;
      }

      /**
       * \brief >>> 设置样式表中的各项样式。
       *
       * \param 总长度项： 要设置的总长度。
       * \param 填充字符： 要设置的填充字符。
       * \param 对齐项： 要设置的对齐方式。
       * \param 进制项： 要设置的进制。
       * \param 精度项： 要设置的精度。
       * \param 正号项： 要设置转换为数值时是否显示正号。
       * \param 额外设定项： 要设置的额外设定，详细见数字转换类型。
       * \return this &
       */
      对象字符串类 &赋值(类型长度 总长度项 = 0, 类型字符 填充字符 = C(' '), 对齐枚举 对齐项 = 对齐枚举::左对齐,
                 类型进制 进制项 = 10, 类型长度 精度项 = 默认精度, 类型字符 正号项 = C('\0'), 转换枚举 额外设定项 = 转换枚举{ }) noexcept
      {
         this->样式表 = 样式表类(总长度项, 填充字符, 对齐项, 进制项, 精度项, 正号项, 额外设定项);
         return *this;
      }

      /**
       * \brief >>> 赋值目标的样式表。
       *
       * \param 赋值项： 要赋值的目标。
       * \return this &
       */
      对象字符串类 &赋值(const 对象字符串类 &赋值项) noexcept
      {
         this->样式表 = 赋值项.样式表;
         return *this;
      }

      /**
       * \brief >>> 获取类中存储的字符串。
       *
       * \return 类中存储的字符串类只读引用。
       */
      const 字符串类 &获取字符串() const noexcept
      {
         return this->类中字符串;
      }

      /**
       * \brief >>> 获取类中存储的字符串类产生的错误信息。
       *
       * \return 类中存储的字符串类产生的错误信息。
       */
      类型错误 获取错误() const noexcept
      {
         return this->类中字符串.获取错误();
      }

      protected:

      字符串类 类中字符串{ };

      public:

      // 赋值目标的样式表。
      对象字符串类 &operator = (const 对象字符串类 &赋值项) noexcept
      {
         return this->赋值(赋值项);
      }

      // 设置额外设定值的掩码值。
      对象字符串类 &operator |= (转换枚举 枚举项) noexcept
      {
         ::BE::设置掩码(this->样式表.额外设定值, 枚举项);

         return *this;
      }

      // 使用给定的转换设定参数将指定可以转换为字符串的对象转换为字符串并赋值，然后将其返回。
      template<可转字符串类型 TmpT>
      const 字符串类 &operator () (TmpT &&赋值项) noexcept
      {
         if constexpr (相同类型<TmpT, 类型字符>)
         {
            if (::BE::掩码判断(this->样式表.额外设定值, ::BE::转换枚举::字符重复))
            {
               this->类中字符串.赋值(赋值项, this->样式表.总长度);
            }
            else
            {
               this->类中字符串.赋值(赋值项);
            }

            if (::BE::掩码判断(this->样式表.额外设定值, ::BE::转换枚举::字符格式) && this->样式表.总长度 != 0)
            {
               ::BE::字符串对齐(this->类中字符串, this->样式表.总长度, this->样式表.填充字符, this->样式表.对齐方式);
            }
         }
         else 
         {
            if constexpr (严格整数类型<TmpT>)
            {
               this->类中字符串.赋值(赋值项, this->样式表.进制值, this->样式表.正号值, this->样式表.额外设定值);
            }
            else if constexpr (浮点类型<TmpT>)
            {
               this->类中字符串.赋值(赋值项, this->样式表.精度值, this->样式表.进制值, this->样式表.正号值, this->样式表.额外设定值);
            }
            else
            {
               this->类中字符串 = ::BE::转字符串类<TmpT>()(赋值项);
            }

            if (this->样式表.总长度 != 0)
            {
               ::BE::字符串对齐(this->类中字符串, this->样式表.总长度, this->样式表.填充字符, this->样式表.对齐方式);
            }
         }

         return this->类中字符串;
      }

      // 转为字符串但获取副本而非引用。
      template<可转字符串类型 TmpT>
      字符串类 operator [] (TmpT &&赋值项) noexcept
      {
         return this->operator()(std::forward<TmpT>(赋值项)).获取副本();
      }

      // 隐式转换为字符串类。
      operator const 字符串类 &() const noexcept
      {
         return this->获取字符串();
      }

      // 如果类中存储的字符串没有产生错误信息则
      explicit operator 类型逻辑() const noexcept
      {
         return this->类中字符串.无错误的();
      }
   };

}
